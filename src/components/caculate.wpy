<template lang="wxml">
  <view>
    <view class="caculation">
      <view class="screen">
        <view class="fs21">{{ amount }}</view>
        <view class="fs12">{{ formula }}</view>
      </view>
      <view class="btnGroup">
        <view class="item" data-num="7" @tap="caculatBtn">7</view>
        <view class="item" data-num="8" @tap="caculatBtn">8</view>
        <view class="item" data-num="9" @tap="caculatBtn">9</view>
        <view class="item" data-num="minus" @tap="caculatBtn">-</view>
      </view>

      <view class="btnGroup">
        <view class="item" data-num="4" @tap="caculatBtn">4</view>
        <view class="item" data-num="5" @tap="caculatBtn">5</view>
        <view class="item" data-num="6" @tap="caculatBtn">6</view>
        <view class="item" data-num="plus" @tap="caculatBtn">+</view>
      </view>

      <view class="btnGroup">
        <view class="item" data-num="1" @tap="caculatBtn">1</view>
        <view class="item" data-num="2" @tap="caculatBtn">2</view>
        <view class="item" data-num="3" @tap="caculatBtn">3</view>
        <view class="item" data-num="eq" @tap="caculatBtn">=</view>
      </view>

      <view class="btnGroup">
        <!-- <view class="item" data-num=".">.</view> -->
        <view class="item" data-num="cls" @tap="caculatBtn">C</view> 
        <view class="item" data-num="0" @tap="caculatBtn">0</view>
        <view class="item" data-num="del" @tap="caculatBtn">
          <image class="caculate-back" data-num="del" @tap="caculatBtn" src="../../public/images/caculate-back.png"></image>
        </view>
        <view class="item" @tap="caculatok">OK</view>
      </view>
    </view>
  </view>
</template>

<script>
import wepy from 'wepy';
export default class Caculate extends wepy.component {
    data = {
      formula: '',
      amount: 0,
      op: {
        'plus': '+',
        'minus': '-',
        'mul': '*',
        'div': '/'
      },
      opArr: ['+', '-', '*', '/'],
      infix: [],
      suffix: [],
      result: [],
      lastVal: 0,
      calcDone: false
    };

    methods = {
      caculatBtn(event) {
        var val = event.target.dataset.num;
        var action = val;
        if (!isNaN(parseInt(val, 10))) {
          this.buildInfix(parseInt(val, 10), 'add');
          this.calculate();
          // 操作：清除、删除、计算等于
        } else if (['cls', 'del', 'eq'].indexOf(val) !== -1) {
          if (this.infix.length == 0) {
            this.resetData();
            return;
          }
          // 清空
          if (action === 'cls' || (action === 'del' && this.calcDone)) {
            this.resetData();
          } else if (action === 'del') {
            // 重新构建中缀表达式
            this.buildInfix('', 'del');
            this.calculate();
          } else if (action === 'eq') {
            this.calculate('eq');
          }
        } else if (this.isOp(this.op[action])) {
          if (!this.infix.length && (this.op[action] === '*' || this.op[action] === '/')) {
            return;
          }
          this.buildInfix(this.op[action], 'add');
        }

        let formula = this.infix.join('');
        formula = (formula.length == 0) ? formula : formula + '='
        if (action === 'eq') formula = ''
        this.formula = formula 
      },
      caculatok() {
        this.infix          = []
        this.suffix         = []
        this.result         = []
        this.lastVal        = 0
        this.formula        = ''
        this.curDot         = false
        this.showCaculation = false
        this.$emit('invokeCaculation', this.amount)
      }
    };

    // 计算器的方法
    resetData () {
      this.infix = []
      this.suffix = []
      this.result = []
      this.lastVal = 0
      this.curDot = false
      this.amount = '0.00'
    }

    isOp (op) {
      return op && this.opArr.indexOf(op) !== -1;
    }

    // 判断运算符优先级
    priorHigher (a, b) {
      return (a === '+' || a === '-') && (b === '*' || b === '/');
    }

    opCalc (b, op, a) {
      switch(op) {
        case '+':
          return a + b;
        case '-':
          return a - b;
        case '*':
          return a * b;
        case '/':
          return a / b;
        default:
          return 0;
      }
    }

    // 构建中缀表达式
    buildInfix (val, type) {
      var newVal;
      // 标志着计算已经完成
      if (this.calcDone) {
        this.calcDone = false;
        if (!this.isOp(val)) {
          this.resetData();
        } else {
          var re = this.result[0];
          this.resetData();
          this.infix.push(re);
        }
      }

      if (type === 'del') {
        newVal = this.infix.pop();
        newVal = Math.floor(newVal / 10);
        if (newVal) {
          this.infix.push(newVal);
        }
        if (this.infix.length - 1 >= 0) {
          this.lastVal = this.infix[this.infix.length - 1];
        } else {
          this.lastVal = 0;
        }
      } else if (type === 'add') {
        // 两个连续的运算符
        if (this.isOp(val) && this.isOp(this.lastVal)) {
          newVal = this.infix.pop();
          this.infix.push(val);
          return this.infix;
        } else if (!this.isOp(val) && !this.isOp(this.lastVal)) {
          newVal = this.lastVal * 10 + val;
          this.infix.pop();
          this.lastVal = newVal
          this.infix.push(newVal);
          return this.infix;
        }
        this.lastVal = val;
        this.infix.push(val);
        return this.infix;
      }
    }

    calculate (type) {
      if (this.infix.length % 2 == 0 && this.infix.length != 1) {
        return
      }
      this.infix2Suffix()
      this.calcSuffix()
      if (this.amount) {
        if (type === 'eq') {
          this.calcDone = true
          this.lastVal = this.amount
        }
      }
    }

    calcSuffix () {
      this.result = [];
      for (var i = 0; i < this.suffix.length; i++) {
        if (!this.isOp(this.suffix[i])) {
          this.result.push(this.suffix[i])
        } else {
          this.result.push(this.opCalc(this.result.pop(), this.suffix[i], this.result.pop()))
        }
      }
      this.amount = this.result.length == 0 ? '0.00' : `${this.result[0]}.00`
    }

    // 中缀表达式转后缀
    infix2Suffix () {
      let temp = []
      this.suffix = []
      for (var i = 0; i < this.infix.length; i++) {
        if (!this.isOp(this.infix[i])) {
          this.suffix.push(this.infix[i])
        }
        else {
          if (!temp.length) {
            temp.push(this.infix[i])
          } else {
            var opTop = temp[temp.length - 1]
            // 循环判断运算符优先级，将运算符较高的压入后缀表达式
            if (!this.priorHigher(opTop, this.infix[i])) {
              while (temp.length && !this.priorHigher(opTop, this.infix[i])) {
                this.suffix.push(temp.pop())
                opTop = temp[temp.length - 1]
              }
            }
            // 将当前运算符也压入后缀表达式
            temp.push(this.infix[i])
          }
        }
      }
      // 将剩余运算符号压入
      while (temp.length) {
        this.suffix.push(temp.pop())
      }
    }

    
}
</script>

<style lang="less">
  .caculation {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 666;
    .screen {
      padding: 6px 10px;
      color: white;
      text-align: right;
      background: rgba(62,64,82,0.9);
    }
  }

  .caculation .close {
    width: 35px;
    position: absolute;
    right: 0;
    top: -26px;
    text-align: center;
    background: #efefef;
    border: 1px solid #ccc;
    height: 25px;
  }

  .caculation .close image {
    width: 20px;
    height: 25px;
    display: inline-block;
  }

  .caculation .btnGroup {
    display: flex;
    flex-direction: row;
    border-top: 1px solid #323546;
  }

  .caculation .btnGroup > .item {
    text-align: center;
    width: 25%;
    padding: 14px 0;
    background: #3e4052;
    border-left: 1px solid #323546;
    color: white;
  }

  .caculate-back {
    width: 25px;
    height: 25px;
    margin-top: 5px;
  }

  .caculation .btnGroup > .item:first-child {
    border-left: none;
  }
</style>